{
    "scheduleOption": 0,
    "metadata": {
        "currentUuid": "ei4h6gcaRaWUNiqwRPUUrA",
        "originalUuid": "ei4h6gcaRaWUNiqwRPUUrA",
        "authorCompanyUuid": "06f7e322-020f-47a8-bca5-05b422d79700",
        "registryVersion": "1.0.0",
        "checksum": "2a89af9645aaa3556a549028dbc54716"
    },
    "dataType": 0,
    "description": "by Stefan Wuensch, October 2020. Take VMware Guest Tags from vCenter Instances and apply them as Properties to the VM monitored Resource. See detailed notes about usage and requirements in the Groovy script.",
    "appliesTo": "VMWare_Guests()\n&& system.displayname !~ \".med.harvard.edu$\"",
    "technology": "",
    "type": 5,
    "params": [
        {
            "name": "linuxcmdline",
            "comment": "",
            "value": ""
        },
        {
            "name": "linuxscript",
            "comment": "",
            "value": ""
        },
        {
            "name": "scriptgroovy",
            "comment": "",
            "value": "// HUIT_VMware_Tags PropertySource Prod 2021-03-10\n// https://harvard.logicmonitor.com/santaba/uiv3/setting/index.jsp#propertyrules/190\n\n// by Stefan Wuensch, October 2020\n// Updated by Stefan, March 2021 to use VM Status DataSource which also includes PoweredOff VMs\n//\n// How does one get VMware Guest Tags to appear on the LM Resource which is the VM Guest?\n// This is how! Use the Guest MAC and IP addresses to search for the Instance in vCenter\n// on the DataSource \"VMware_vCenter_VMStatus\" (because that's where Tags appear)\n// and then copy all the Auto Properties from that Instance to the monitored Device.\n// We will use our own prefix so that name collisions won't be an issue.\n// We use the LM API to avoid overloading the vCenter API.\n//\n// In addition, we will generate at least two new Auto Properties showing\n// the start time of the run, and the outcome (good/bad/ugly) at the end.\n//      {prefix}.propertysource.start  -->  timestamp of the start\n//      {prefix}.propertysource.status -->  message starting with either \"OK\" or \"Failed\"\n// Note that the \"OK\" and \"Failed\" are in globals for easy changing if needed.\n// Input and output Property name prefixes are also in globals for easy customization.\n//\n//\n// Required Device Properties for this PropertySource to work:\n//   VMware_Tags.lmaccount              - LM portal name (as in lmaccount.logicmonitor.com)\n//   VMware_Tags.lmaccess.id            - LM API Token Access ID\n//   VMware_Tags.lmaccess.key           - LM API Token Key\n//   VMware_Tags.vCenter_Server.name    - system.hostname of the VMware vCenter Server in LM\n//   auto.network.mac_address           - VM Guest MAC address, used to find Instance on vCenter Device\n//   auto.network.address               - VM Guest IP address, used to find Instance on vCenter Device\n//   \n// Optional Device Properties:\n//   collector.proxies.config           - JSON configuration for web proxy if needed for Collector egress\n//   (Web proxy password Property)      - Property Name that contains proxy password (if needed) as specified\n//                                          in the \"proxy.pass.propertyname\" JSON element\n//\n// Shout-out to Stuart Weenig for ideas, for code samples, and for being awesome.\n//\n// Note: all the significant helper methods are copied from DataSource \"LogicMonitor_Portal_Metrics\"\n// (v1.5 lmLocator 7AGWZ6) for the purposes of re-using code provided by and supported by\n// LogicMonitor. This means that some parts of the unique code in this script are not\n// as easy to read, nor as compact, as they could be. I thought it better to re-use\n// common methods for LM API access rather than to have all original code that might be\n// more efficient. -- SW\n//\n\n// To configure web proxies for any / each Collector, create a Device Property named\n// \"collector.proxies.config\" with a schema like this example. Note that multiple\n// proxy configurations can be created, and are mapped to the Collector ID as applicable.\n/*\n{\n    \"proxy_collectors\": {\n        \"7\":  \"config_A\",\n        \"8\":  \"config_B\",\n        \"21\": \"config_A\",\n        \"22\": \"config_B\"\n    },\n    \"config_A\": {\n        \"comment\":      \"This example proxy is for prod servers\",\n        \"proxy.host\":   \"10.0.1.10\",\n        \"proxy.port\":   \"8080\",\n        \"proxy.schema\": \"https\",\n        \"proxy.user\":   \"\",\n        \"proxy.pass.propertyname\": \"\"\n    },\n    \"config_B\": {\n        \"comment\":      \"This is another example\",\n        \"proxy.host\":   \"my.example.proxy.com\",\n        \"proxy.port\":   \"8888\",\n        \"proxy.schema\": \"http\",\n        \"proxy.user\":   \"john_sample\",\n        \"proxy.pass.propertyname\": \"collector.proxy.password\"\n    }\n}\n\n*/\n\n\nimport javax.crypto.Mac\nimport javax.crypto.spec.SecretKeySpec\nimport groovy.json.JsonSlurper\nimport groovy.json.JsonOutput ;\nimport groovy.time.TimeCategory ;\nimport com.santaba.agent.groovyapi.http.* ;\n\n\n// Set globals for prefixes and important status flags\nautoprop_prefix = \"auto.vcenter\" ;\nmy_name         = \"VMware_Tags\" ;\nstatus_OK_str   = \"OK\" ;\nstatus_Fail_str = \"Failed\" ;\n\n// This is in case things like API time-outs show up. Compare this time\n// to the \"status\" property which should be always the last one output.\nprintln \"${autoprop_prefix}.propertysource.start=\" + time_now() ;\n\n\n// Build map of customer account credentials (located on LM Portal)\nMap credentials = [\n    \"account\": hostProps.get( \"${my_name}.lmaccount\" ),\n    \"id\"     : hostProps.get( \"${my_name}.lmaccess.id\" ),\n    \"key\"    : hostProps.get( \"${my_name}.lmaccess.key\" )\n] ;\n\n\n// Get the Properties we need in order to find vCenter, and this\n// VM among all the Guest Instances on vCenter.\nString vcenter_name = hostProps.get( \"${my_name}.vCenter_Server.name\" ) ;\nString primary_MAC  = hostProps.get( \"auto.network.mac_address\" ) ;\nString primary_IP   = hostProps.get( \"auto.network.address\" ) ;\n\nweb_proxies = get_proxies() ?: [:] ;   // Making this Map a \"global\" so it's available to methods without editing input parameters\n\n\n// Make sure we have what we need, or bail out.\n// If we fail, we'll give a helpful status message as a Property.\nif ( ! ( credentials.account && credentials.id && credentials.key ) ) {\n    println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} on API credentials at ${time_now()} \" +\n             \"Device is not configured with the necessary credentials to proceed with API queries. \" +\n             \"Please ensure that \\\"${my_name}.lmaccount\\\", \\\"${my_name}.lmaccess.id\\\", and \\\"${my_name}.lmaccess.key\\\" are set in the Properties section!\"\n    ) ;\n    return 0 ;\n}\nif ( ! ( vcenter_name && primary_MAC && primary_IP ) ) {\n    println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} on incomplete Device Properties at ${time_now()} \" +\n             \"Could not get the necessary information to proceed with VM Tag matching. \" +\n             \"Please ensure that \\\"${my_name}.vCenter_Server.name\\\", \\\"auto.network.mac_address\\\", and \\\"auto.network.address\\\" are available in the Device Properties section!\"\n    ) ;\n    return 0 ;\n}\n\n\n// IMPORTANT: Filters must be URLencoded, EXCEPT where variables are being used.\n// (Generally this just means replacing spaces with '+')\n// Note the use of tokens which will be replaced in later stages as those data are gathered.\nMap resources = [\n\n    \"get_vcenter_ID\": [\n        \"comment\": \"This gets the Device ID of the VMWare vCenter server whose name provided as a Property.\",\n        \"path\": \"/device/devices\",\n        \"data\": [:],\n        \"details\":  [\n            \"fields\": \"id,name,displayName\",\n            \"filter\": \"displayName:${vcenter_name},systemProperties.name:system.virtualization,systemProperties.value:VMWare+ESX+vcenter\"\n        ]\n    ],\n\n    \"get_dataSourceId\": [\n        \"comment\": \"This uses the vCenter server Device ID from the previous query to get the Device DataSource ID for VMware VM Status.\",\n        \"path\": \"/device/devices/###vcenter_ID###/devicedatasources\",\n        \"data\": [:],\n        \"details\":  [\n            \"fields\": \"id,dataSourceId,dataSourceName\",\n            \"filter\": \"dataSourceName:VMware_vCenter_VMStatus\"\n        ]\n    ],\n\n    \"get_instances\": [\n        \"comment\": \"This uses the vCenter Device ID and the Device DataSource ID from previous queries to get Auto Properties for this VM, based on MAC and IP.\",\n        \"path\": \"/device/devices/###vcenter_ID###/devicedatasources/###datasource_ID###/instances\",\n        \"data\": [],         // Note this is a List not a Map, because we need to handle the possibility of multiple matches.\n        \"details\":  [\n            \"fields\": \"name,displayName,autoProperties\",\n            \"filter\": \"autoProperties.name:auto.hardware.nic0.mac_address,autoProperties.value~${primary_MAC},autoProperties.name:auto.hardware.nic0.ip_addresses,autoProperties.value~${primary_IP}\"\n//            \"filter\": \"autoProperties.name:auto.hardware.nic0.mac_address,autoProperties.value~00:50:56:8b:5f\"      // Test case that deliberately matches 6 VMs\n        ]\n    ]\n\n] ;\n\n\n// --------------------------------------------------------------------------------------------------------------------------------------------\n// Now in three stanges, we make the API calls.\n// (This might be possible to do in a helper method instead, but we need to replace tokens in the 'path' parameters, and re-use all\n// the existing methods we have from an existing DataSource without changing them.)\n\n// ---- Stage 1 ------------------------\ndef this_one = \"get_vcenter_ID\" ;\n\nMap headers = generate_headers( credentials.id, credentials.key, resources[ this_one ].path ) ;\nif ( headers ) {\n    Map this_response = get_response( this_one, resources[ this_one ], credentials.account, headers ) ;\n    if ( this_response?.success && this_response?.response?.size() != 0 ) { resources[ this_one ][ \"data\" ] << this_response.response }\n    else { println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} API response for ${this_one} at ${time_now()} (internal error)\" ) ; return 0 ; }\n}\nelse { println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} generating API auth headers for ${this_one} at ${time_now()} (internal error)\" ) ; return 0 ; }\n\ndef vcenter_ID = resources[ this_one ].data?.id?.toString() ;\nif ( ! vcenter_ID ) { println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} to find vCenter ID in ${this_one} from LM API at ${time_now()}\" ) ; return 0 ; }\n\n\n\n// ---- Stage 2 ------------------------\nheaders = [:]   // Reset to empty\nthis_one = \"get_dataSourceId\" ;\nresources[ this_one ].path = resources[ this_one ].path.replace( \"###vcenter_ID###\", vcenter_ID ) ;\n\nheaders = generate_headers( credentials.id, credentials.key, resources[ this_one ].path ) ;\nif ( headers ) {\n    Map this_response = get_response( this_one, resources[ this_one ], credentials.account, headers ) ;\n    if ( this_response?.success ) { resources[ this_one ][ \"data\" ] << this_response.response }\n    else { println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} API response for ${this_one} at ${time_now()} (internal error)\" ) ; return 0 ; }\n}\nelse { println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} generating API auth headers for ${this_one} at ${time_now()} (internal error)\" ) ; return 0 ; }\n\ndef datasource_ID = resources[ this_one ].data?.id?.toString() ;\nif ( ! datasource_ID ) { println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} to find DataSource ID in ${this_one} from LM API at ${time_now()}\" ) ; return 0 ; }\n\n\n\n// ---- Stage 3 ------------------------\nheaders = [:]   // Reset to empty\nthis_one = \"get_instances\" ;\nresources[ this_one ].path = resources[ this_one ].path.replace( \"###vcenter_ID###\", vcenter_ID ).replace( \"###datasource_ID###\", datasource_ID ) ;\n\nheaders = generate_headers( credentials.id, credentials.key, resources[ this_one ].path ) ;\nif ( headers ) {\n    Map this_response = get_response( this_one, resources[ this_one ], credentials.account, headers ) ;\n    if ( this_response?.success ) { resources[ this_one ][ \"data\" ] = this_response.response }\n    else { println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} API response for ${this_one} at ${time_now()} (internal error)\" ) ; return 0 ; }\n}\nelse { println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} generating API auth headers for ${this_one} at ${time_now()} (internal error)\" ) ; return 0 ; }\n\n// End of the three stage data collection.\n// --------------------------------------------------------------------------------------------------------------------------------------------\n\n\n\n// We now have everything we can get. Make sure it's only one matching VM!\n// If not just one, give a helpful status message and bail out.\ndef instances_count = resources?.get_instances?.data?.size() ;\ndef instances_names = resources?.get_instances?.data?.collect{ it.displayName } ;\ndef instances_names_text = \"\" ;\nif ( instances_count > 1 ) {\n    instances_names_text = \"with Instance Display Names ${instances_names} \" ;\n}\nif ( instances_count != 1 ) {\n    println( \"${autoprop_prefix}.propertysource.status=${status_Fail_str} results count at ${time_now()} found ${instances_count} matches \" +\n             instances_names_text +\n             \"for MAC \\\"${primary_MAC}\\\" and IP \\\"${primary_IP}\\\" on vCenter server \\\"${vcenter_name}\\\"\" \n    ) ;\n    return 0 ;\n}\n\n// Since we know we have only one match, grab that single list item as a string.\ndef displayName = instances_names?.getAt( 0 ).toString() ;\n\n\n\n// Make sure we're not looking at a VM which is the vCenter server itself. If we are, skip it!\n// Because Device Properties get inherited by DataSource Instances, it's really confusing to have\n// Properties related to the vCenter VM showing up on Instances which are other Guest VMs!\nif ( hostProps.get( \"system.deviceId\" ) == vcenter_ID ) {\n    println( \"${autoprop_prefix}.propertysource.status=${status_OK_str} / Skipping VM Tag propagation on this VM Resource \" +\n             \"\\\"${displayName}\\\" because this is the vCenter server \\\"${vcenter_name}\\\" itself, and the Properties \" +\n             \"would be inherited by the Guest Instances and make things very confusing. / Finished at ${time_now()}\"\n    ) ;\n    return 0 ;\n}\n\n\n\n// Finally, after all that... Output all the vCenter Instance Auto Properties! Yay!\n// Also include the vCenter Instance displayName for cross-reference.\nprintln( \"${autoprop_prefix}.displayName=${displayName}\" ) ;\n// Iterate over the nested items, removing the existing \"auto\" prefix first. (Our prefix contains \"auto.\")\nresources?.get_instances?.data?.autoProperties?.each() { pair ->\n    pair.each() {\n        String output_name = it.name.minus( \"auto.\" ) ;\n        println( \"${autoprop_prefix}.${output_name}=${it.value}\" ) ;\n    }\n}\n\n\n\n//println( \"${autoprop_prefix}.propertysource.fun=wheeee\" ) ;                             // Debug\n//println( \"${autoprop_prefix}.datasize=${resources?.get_instances?.data?.size()}\" ) ;    // Debug\n//println( \"${autoprop_prefix}.debug=${JsonOutput.toJson( resources ) }\" ) ;              // Debug\n\n\n\n// All done! Give a wrap-up message with a summary.\ndef autoProperties_size = resources?.get_instances?.data?.getAt( 0 )?.autoProperties?.size() ;\nprintln( \"${autoprop_prefix}.propertysource.status=${status_OK_str} / Finished at ${time_now()} / \" +\n         \"Matched VM Instance \\\"${displayName}\\\" on vCenter server \\\"${vcenter_name}\\\" \" +\n         \"and replicated ${autoProperties_size} Properties from the vCenter Guest Instance.\"\n) ;\nreturn 0 ;\n\n\n\n\n/* ************************************************************************************************************** */\n// Custom helper method(s)\n\n\n// Generate string of current time\ndef time_now() {\n    return new Date().format( 'yyyy-MM-dd HH:mm:ss' ) ;\n}\n\n\n\n// Create map for any web proxy needed on this Collector. Returns Map.\ndef get_proxies() {\n\n\t// Get the Web Proxy configuration (if it exists) for use in the HTTP connection.\n\t// The schema for this Map is illustrated in comments at this top of this script.\n\tdef my_collectorid = hostProps.get( \"system.collectorid\" ) ?: \"0\" ;  // We'll be using this for a Map lookup later\n\t//my_collectorid = \"99\" // debug\n\n\tMap proxies_map = [:] ;     // This will contain all Collector proxy configs, from the Property - if it exists.\n\tString json_config = hostProps.get( \"collector.proxies.config\" ) ?: \"{}\" ;  // parseText() does not like a null!\n\ttry {\n\t\tproxies_map = new JsonSlurper().parseText( json_config ) ;\n\t} catch ( Exception err ) {\n\t\t// Just in case someone puts something weird in the Property which makes the Slurper unhappy.\n\t\t// Since the proxy config is optional anyway - and we initialized the map - this is belt-and-suspenders safety. :-)\n\t\t// Note that we are assuming the \"status\" Property will be over-written by a later step.\n\t\t// This println() is here primarily for really odd edge cases.\n\t\tprintln( \"${autoprop_prefix}.propertysource.status=${status_OK_str} but there was a problem parsing JSON from Property \\\"collector.proxies.config\\\" ${err?.message}\" )\n\t}\n\n\t// If we did get a proxy config for this Collector, use it!\n\t// Note we're doing everything null-safe with getAt() because it's user input from Properties!\n\t// We don't want to assume the Map schema is what it should be.\n\t// System Property Reference: https://docs.oracle.com/en/cloud/saas/enterprise-performance-management-common/prest/groovy_sample_pbcsrestclient.groovy.html\n\t// and https://generacodice.com/en/articolo/37540/How-can-I-enumerate-all-%2A.exes-and-the-details-about-each\n\t// and https://www.logicmonitor.com/support/terminology-syntax/scripting-support/access-a-website-from-groovy\n\t\n\t// Also note: System.setProperty() makes a *persistent* change to the JVM (as of 2020-10-27) which is sub-optimal. Those VM-wide settings lines of code are\n\t// kept here but disabled, in case it's desired behavior. Instead this method returns a Map to be used in setHTTPProxy() on a httpClient object.\n\n\tif ( proxies_map?.getAt( \"proxy_collectors\" )?.containsKey( my_collectorid ) ) {                    // Is this Collector ID a key in the map?\n\t\tString config_name = proxies_map?.getAt( \"proxy_collectors\" )?.getAt( my_collectorid ) ;        // This is for making the notation a little shorter.\n\t\tif ( proxies_map?.containsKey( config_name ) ) {                                                // Is the config by this name in the map?\n\t\t\tString my_schema = proxies_map?.getAt( config_name )?.getAt( \"proxy.schema\" ) ?: \"https\" ;  // Use https if not otherwise specified\n\n\t\t\t// Take care of Host / Port first, and use a null if it's not found.\n\t\t\t// Note we are NOT doing any validation of the values. If someone got the JSON schema correct\n\t\t\t// to this level, we'll assume they knew what they were doing enough to give proper values.\n            /* See note above about System.setProperty()\n\t\t\tSystem.setProperty( \"${my_schema}.proxyHost\", proxies_map?.getAt( config_name )?.getAt( \"proxy.host\" ) ?: \"\" ) ;\n\t\t\tSystem.setProperty( \"${my_schema}.proxyPort\", proxies_map?.getAt( config_name )?.getAt( \"proxy.port\" )?.toInteger() ?: \"\" ) ;\n\t\t\t*/\n\t\t\tMap return_map = [\n\t\t\t    \"schema\": my_schema,\n\t\t\t    \"host\": proxies_map?.getAt( config_name )?.getAt( \"proxy.host\" ) ?: \"\",\n\t\t\t    \"port\": proxies_map?.getAt( config_name )?.getAt( \"proxy.port\" )?.toInteger() ?: \"\"\n\t        ] ;\n\t\t\n\t\t\t// Proxy password is in a separate Device Property, which keeps it safe.\n\t\t\tString password_prop_name = proxies_map?.getAt( config_name )?.getAt( \"proxy.pass.propertyname\" ) ?: \"\" ; // Get the name of that Property\n\t\t\tif ( password_prop_name ) {\n                /* See note above about System.setProperty()\n\t\t\t    System.setProperty( \"${my_schema}.proxyUser\", proxies_map?.getAt( config_name )?.getAt( \"proxy.user\" ) ?: \"\" ) ;\n\t\t\t\tSystem.setProperty( \"${my_schema}.proxyPassword\", hostProps.get( password_prop_name ) ?: \"\" ) ;    // hostProps.get() returns null if not found, but we want empty string\n\t\t\t\t*/\n\t\t\t    return_map[ \"user\" ] = proxies_map?.getAt( config_name )?.getAt( \"proxy.user\" ) ?: \"\" ;\n\t\t\t\treturn_map[ \"pass\" ] = hostProps.get( password_prop_name ) ?: \"\" ;\n\t\t\t}\n\n            return return_map ;\n\t\t}\n\t}\n\n}\n\n\n\n\n/* ************************************************************************************************************** */\n// Helper methods from here to end, copied from DataSource LogicMonitor_Portal_Metrics v1.5 lmLocator 7AGWZ6\n// Note that minor changes have been made to the error output, so that it conforms to PropertySource format\n// which requires \"name=value\" for all lines.\n\ndef generate_headers(id, key, path) {\n    try {\n        // Create encryption signature for authorization request\n        Long epoch_time = System.currentTimeMillis()    // Get current system time (epoch time)\n        Mac hmac = Mac.getInstance(\"HmacSHA256\")\n        hmac.init(new SecretKeySpec(key.getBytes(), \"HmacSHA256\"))\n\n        signature = hmac.doFinal(\"GET${epoch_time}${path}\".getBytes()).encodeHex().toString().bytes.encodeBase64()\n        // return headers to main function\n        return [\"Authorization\": \"LMv1 $id:$signature:$epoch_time\", \"Content-Type\": \"application/json\"]\n    } catch (Exception err) {\n        // If error occurred, print the error message\n        // println(\"ERROR: Unable to establish encryption for $path. Attempting next resource...\\n${err.message}\")      // Original line from LM DataSource\n        println(\"${autoprop_prefix}.propertysource.status=${status_Fail_str} ERROR: Unable to establish encryption for $path. Attempting next resource... ${err.message}\") // Output fixed for PropertySource\n    }\n}\n\ndef get_response(resource, parameters, account, headers) {\n    try {\n        boolean proceed = true  // Boolean used to determine if additional pagination is required\n        // Map to store query results for each endpoint.  Contains a list to store actual returned values and a boolean to determine if successful\n        Map results = [\"response\": [],\n                       \"success\" : true]\n        add_query_parameters(resource, parameters)\n        // Add initial offset and size values to appropriate categories (skips metrics category since it's stagnate)\n        while (proceed) {\n            // Used for paginating through all availabe results.  Grabs 1000 at a time and moves offset if another query is required.\n            Map query = query_resource(account, parameters, headers)\n            // Query each API endpoint for a response (Should receive as Map)\n            // If the response was successful (including status and error messages), proceed to printing results\n            if (query && query?.data && query?.status == 200 && query?.errmsg?.toUpperCase() == \"OK\") {\n                if (resource != \"metrics\") {\n                    results.response.addAll(query.data.items)   // Add all the data items found to our results map data list\n                    if (query?.data?.items?.size() < parameters.details.size) {\n                        // If we received less than 1000 results\n                        proceed = false     // There is no need to execute another API query with a shifted offset\n                    } else {        // Otherwise\n                        parameters.details.offset += parameters.details.size\n                        // Shift the offset to start 1000 numbers from current position\n                    }\n                } else {\n                    results.response = query.data   // Add all the data items found to our results map data list\n                    proceed = false     // We've successfully queried all values.  End while loop\n                }\n            } else {\n                // If response was not successful, print eror message for each category that failed and continue to next endpoint\n                // If response error and status can be determined, print them.  Otherwise, use UNKNOWN\n                // println(\"ERROR: Failed to query $resource API Endpoint...\\n\" +   // Original line from LM DataSource\n                println(\"${autoprop_prefix}.propertysource.status=${status_Fail_str} ERROR: Failed to query $resource API Endpoint... \" +  // Output fixed for PropertySource\n                        \"${query?.errmsg?.toUpperCase() ?: 'UNKNOWN'} (STATUS: ${query?.status ?: 'UNKNOWN'})\")\n                results.success = false     // Set success value to false since we failed our API query\n                proceed = false   // End while loop because of failure and proceed to next endpoint\n            }\n        }\n        return results  // Return results to main function\n    } catch (Exception err) {\n        // println(\"ERROR: Script failed while attempting to query $resource API endpoint...\\n${err?.message}\") // Original line from LM DataSource\n        println(\"${autoprop_prefix}.propertysource.status=${status_Fail_str} ERROR: Script failed while attempting to query $resource API endpoint... ${err?.message}\") // Output fixed for PropertySource\n    }\n}\n\ndef add_query_parameters(category, parameters) {\n    // Add size and offset field to map (only if collectors or admins category)\n    if (category != \"metrics\") {\n        Map query_details = [\"size\"  : 1000,\n                             \"offset\": 0]\n        // If there's already a details key in the details map\n        if (parameters.details) {\n            parameters.details << query_details\n            // Append the query details information to the pre-existing details map\n        } else {    // Otherwise, create a details key and assign it the query details map as a value\n            parameters.put(\"details\", query_details)\n        }\n    }\n}\n\ndef query_resource(account, details, headers) {\n    try {\n        // Configure request url from account, path, and authorization headers\n        String url = \"https://${account}.logicmonitor.com/santaba/rest${details.path}?${pack_parameters(details.details)}\"\n        // Return query response, converted from JSON to usable map\n        // Next line is from original DataSource, but doesn't work with web proxies.\n        // return new JsonSlurper().parseText(url.toURL().getText(useCaches: true, allowUserInteraction: false, requestProperties: headers))\n\n        // Next lines added by Stefan Wuensch, October 2020, to be able to use web proxies\n        // println( \"${autoprop_prefix}.debug=${JsonOutput.toJson( web_proxies ) }\" ) ;    // Debug\n        def client = HTTP.open( \"${account}.logicmonitor.com\", 443, true ) ;            // Specify SSL (true) for just-in-case belt-and-suspenders coverage\n        if ( web_proxies && web_proxies?.host && web_proxies?.port ) {\n            client.setHTTPProxy( web_proxies?.host, web_proxies?.port, web_proxies?.user, web_proxies?.pass ) ;\n        }\n        def response = client.get( url, headers ) ;         // We don't need this object; it's just to make the get() happen.\n        def response_body = client.getResponseBody() ;\n        return new JsonSlurper().parseText( response_body ) ;\n\n    } catch (Exception err) {\n        // If error occurred, print the error message\n        // println(\"ERROR: Unable to query ${details.path} for details.\\n${err.message}\")  // Original line from LM DataSource\n        println(\"${autoprop_prefix}.propertysource.status=${status_Fail_str} ERROR: Unable to query ${details.path} for details. ${err.message}\")      // Output fixed for PropertySource\n    }\n}\n\ndef pack_parameters(query_details) {\n    // If additional query details are located in map, include them in url string\n    List pairs = []\n    query_details?.each { k, v ->\n        pairs.add(\"${k}=${v}\")\n    }\n    return pairs.join(\"&\")\n}\n\n/* ************************************************************************************************************** */"
        },
        {
            "name": "scripttype",
            "comment": "embed",
            "value": "embed"
        },
        {
            "name": "windowscmdline",
            "comment": "",
            "value": ""
        },
        {
            "name": "windowsscript",
            "comment": "",
            "value": ""
        }
    ],
    "version": 1674061551,
    "tags": "",
    "auditVersion": 0,
    "name": "HUIT_VMware_Tags",
    "id": 190,
    "group": "HUIT Custom"
}